use crate::{
    check_cycles_before_action, is_owner, DataPoint, MODELS, NEXT_DATA_POINT_ID
};

use crate::types::{get_classifier_model_data, UpdatedDetails};
use crate::types::{ModelType, KeyValuePair};
use std::collections::HashMap;
use candid::Principal;

use crate::model::update_model;

#[ic_cdk::update]
/// Adds a dataset to an specified model.
/// 
/// # Arguments
/// - `model_id: u128` - Unique identifier for the model.
/// - `features: Vec<Vec<f64>>` - Nested list of features, where each inner vector represents a set of features for a data point.
/// - `labels: Vec<bool>` - List of labels corresponding to each data point.
/// - `predictions: Vec<bool>` - List of predicted outcomes generated by a model for evaluation.
/// - `privileged: Vec<KeyValuePair>` - List of key-value pairs representing name of privileged column and column index for the features vector.
/// - `selection_labels: Vec<String>` - List of cached field labels for auto-selecting fields on the UI.
pub fn add_dataset(
    model_id: u128,
    features: Vec<Vec<f64>>,
    labels: Vec<bool>,
    predictions: Vec<bool>,
    privileged: Vec<KeyValuePair>,
    selection_labels: Vec<String>,
    model_details: UpdatedDetails,
) {

    check_cycles_before_action();

    // Verify that all columns have consistent lengths (unchanged)
    let data_length = labels.len();
    if predictions.len() != data_length {
        ic_cdk::api::trap("Error: Lengths of labels and predictions must be equal.");
    }
    for feature_column in &features {
        if feature_column.len() != data_length {
            ic_cdk::api::trap("Error: All feature columns must have the same length as labels.");
        }
    }

    let caller: Principal = ic_cdk::api::caller();
    let timestamp: u64 = ic_cdk::api::time();

    // let privileged_map: HashMap<String, u128> = privileged_labels.iter().enumerate().map(|(i, label)| {
    //     (label.clone(), privilege_indices[i])
    // }).collect();

    let privileged_map: HashMap<String, u128> = privileged
        .iter()
        .map(|pair| (pair.key.clone(), pair.value as u128))
        .collect();

    MODELS.with(|models| {
        let mut models = models.borrow_mut();
        let mut model = models.get(&model_id).expect("Model not found");

        is_owner(&model, caller);

        NEXT_DATA_POINT_ID.with(|id| {
            let mut next_data_point_id = id.borrow_mut();
            for i in 0..data_length {
                let mut feature_vector = Vec::new();
                for feature_column in &features {
                    feature_vector.push(feature_column[i]);
                }

                // Determine privileged status using u64 and casting to usize
                // let mut privileged = false;
                // for &index in &privilege_indices {
                //     let idx = index as usize;
                //     if idx < feature_vector.len() && feature_vector[idx] > 0.0 {
                //         privileged = true;
                //         break;
                //     }
                // }

                let data_point = DataPoint {
                    data_point_id: *next_data_point_id.get(),
                    target: labels[i],
                    privileged_map: privileged_map.clone(),
                    predicted: predictions[i],
                    features: feature_vector.clone(),
                    timestamp,
                };

                model.cached_selections = Some(selection_labels.clone());

                let mut model_data = get_classifier_model_data(&model);
                model_data.data_points.push(data_point);
                model.model_type = ModelType::Classifier(model_data);

                models.insert(model_id, model.clone());
                let current_id = *next_data_point_id.get();
                next_data_point_id.set(current_id + 1).unwrap();
            }
        });
    });

    update_model(
        model_id,
        model_details.name.clone(),
        model_details.details.clone(),
        false
    );
}

#[ic_cdk::update]
/// Adds a data point for a specific model.
///
/// This function is used to add a new data point to a specified model using the given parameters.
///
/// # Arguments
/// - `model_id: u128` - Identifier for the model to which the data point should be added.
/// - `target: bool` - The actual target output of the data nature, true if positive, else false.
/// - `privilege_indices: Vec<u128>` - A vector of indices defining privilege-related attributes.
/// - `privileged_labels: Vec<String>` - Labels corresponding to the privileges defined in `privilege_indices`.
/// - `predicted: bool` - The predicted output by the model, true if positive, otherwise false.
/// - `features: Vec<f64>` - A vector of features used as input data for model prediction.
pub fn add_data_point(
    model_id: u128,
    target: bool,
    privilege_indices: Vec<u128>,
    privileged_labels: Vec<String>,
    predicted: bool,
    features: Vec<f64>,
) {
    check_cycles_before_action();
    let caller: Principal = ic_cdk::api::caller();
    let timestamp: u64 = ic_cdk::api::time();

    let privileged_map: HashMap<String, u128> = privileged_labels
        .iter()
        .enumerate()
        .map(|(i, label)| (label.clone(), privilege_indices[i]))
        .collect();

    MODELS.with(|models| {
        let mut models = models.borrow_mut();
        let mut model = models.get(&model_id).expect("Model not found");

        is_owner(&model, caller);

        let mut model_data = get_classifier_model_data(&model);

        NEXT_DATA_POINT_ID.with(|next_data_point_id| {
            let data_point_id = *next_data_point_id.borrow().get();
    
            let data_point: DataPoint = DataPoint {
                data_point_id,
                target,
                privileged_map: privileged_map.clone(),
                predicted,
                features,
                timestamp,
            };
    
            model_data.data_points.push(data_point);
            model.model_type = ModelType::Classifier(model_data);
            models.insert(model_id, model.clone());
            next_data_point_id.borrow_mut().set(next_data_point_id.borrow().get() + 1).unwrap()
        });
    });
}

/// Deletes a specific data point from a model.
///
/// # Arguments
/// * `model_id: u128` - The unique identifier of the model from which the data point will be removed.
/// * `data_point_id: u128` - The unique identifier of the data point to remove.
#[ic_cdk::update]
pub fn delete_data_point(model_id: u128, data_point_id: u128) {
    check_cycles_before_action();
    let caller: Principal = ic_cdk::api::caller();

    MODELS.with(|models| {
        let models = models.borrow_mut();
        let mut model = models.get(&model_id).expect("Model not found");

        is_owner(&model, caller);

        let mut model_data = get_classifier_model_data(&model);

        let data_point_index = model_data
            .data_points
            .iter()
            .position(|d| d.data_point_id == data_point_id)
            .expect("Data point not found");
        model_data.data_points.remove(data_point_index);

        model.model_type = ModelType::Classifier(model_data);
    });
}
